{
    "projects": [
        {
            "name": "Glory Stall",
            "group": "Museum of Sex",
            "grouplinks": "#",
            "link": "glory-stall",
            "date": "Dec 2019-Present",
            "short": "An erotic take on Wack-A-Mole",
            "info": "The Glory Stall is a hilarious take on the Wack-A-Mole game featured in many carnivals and arcades across the country.  Up to 4 players can compete to see who can pull the most as phallic shaped objects are pushed randomly through a set of 5 holes in each stall.  The player who can 'yank the most planks' wins their choice of a stuffed pepper, eggplant or banana.  Each stall uses a combination of an Arduino Nano and Raspberry Pi to control the various sensors, hardware, and audio playback in each stall.  Each of the 4 Raspberry Pis connect to a single Raspberry Pi using ethernet cables and a desktop switch.  This single Pi awaits user input from the staff to start and stop the game.  The Pis communicate using Open Sound Control.  On each Pi, a Processing IDE sketch is used to control each stall's Pi and the main Pi controlling the game state changes.  The Processing sketch handles audio playback, reading of incoming state changes, scoreboard updating and communication with the Arduino Nano via the Firmata protocol.  The Nano is used to read sensor data to record pulls and control of the relay module to activate pistons and the winner siren light.",
            "tech": [
                [
                    "Arduino",
                    "https://www.arduino.cc/"
                ],
                [
                    "Raspberry Pi",
                    "https://www.raspberrypi.org/"
                ],
                [
                    "Processing IDE",
                    "https://processing.org/"
                ],
                [
                    "Fusion 360",
                    "https://www.autodesk.com/products/fusion-360/overview"
                ],
                [
                    "Open Sound Control",
                    "https://opensoundcontrol.stanford.edu/"
                ]
            ],
            "photos": [
                "glory-stall/glory-stall-1.jpg",
                "glory-stall/glory-stall-2.jpg",
                "glory-stall/glory-stall-4.jpg",
                "glory-stall/glory-stall-5.jpg",
                "glory-stall/glory-stall-6.jpg",
                "glory-stall/glory-stall-7.jpg",
                "glory-stall/glory-stall-8.jpg",
                "glory-stall/glory-stall-9.jpg"
            ]
        },
        {
            "name": "Lucky Lips",
            "group": "MOS",
            "grouplinks": "https://www.superfunland.com/",
            "link": "lucky-lips",
            "date": "Dec 2019",
            "short": "A two player kissing game",
            "info": "Lucky Lips uses a GSR sensor to measure the strength of two players' kiss.  The players grab ahold of a metal hand rail mounted on opposite sides of the game and when they kiss or make skin-to-skin contact in another way, the GSR sensor measures the conductance of the two players.  If the players can maintain contact throughout the game, they win a random prize from the wheel mounted in the center.  While most prizes are tongue in cheek suggestions, grand prizes such as free hotel rooms or drink tickets were offered.  An Arduino Uno was used to read sensor data and send it to a Raspberry Pi.  The Pi ran a Processing IDE sketch to control game state changes, color patterns for the multiple sections of LED strips, and handle sensor input from the Arduino Uno using the Firmata protocol.  A Python sketch controlled all audio playback, printing of prize tickets, and emailing staff to alert them when the grand prizes were won. The two sketches communicated locally via the Open Sound Protocol.",
            "tech": [
                [
                    "Arduino",
                    "https://www.arduino.cc/"
                ],
                [
                    "Raspberry Pi",
                    "https://www.raspberrypi.org/"
                ],
                [
                    "Python",
                    "https://www.python.org/"
                ],
                [
                    "Processing IDE",
                    "https://processing.org/"
                ],
                [
                    "Open Sound Control",
                    "https://opensoundcontrol.stanford.edu/"
                ],
                [
                    "ArtNet",
                    "https://art-net.org.uk/"
                ],
                [
                    "DMX",
                    "https://en.wikipedia.org/wiki/DMX512"
                ]
            ],
            "photos": [
                "lucky-lips/lucky-lips-1.jpg",
                "lucky-lips/lucky-lips-2.jpg",
                "lucky-lips/lucky-lips-3.jpg",
                "lucky-lips/lucky-lips-4.jpg",
                "lucky-lips/lucky-lips-5.jpg",
                "lucky-lips/lucky-lips-6.jpg",
                "lucky-lips/lucky-lips-7.jpg",
                "lucky-lips/lucky-lips-8.jpg"
            ]
        },
        {
            "name": "Vial Dispenser",
            "group": "MOS",
            "grouplinks": "#",
            "link": "vial-dispenser",
            "date": "Jun 2020",
            "short": "An upgrade to an upgrade",
            "info": "The Vial Dispenser was designed and built as a prototype for a new version of the Siren, a game I helped build for the Museum of Sex NYC.  The game involves a metal crank wheel cleverly placed for players to spin.  If the players can keep the wheel spinning for 45 seconds, they win a vial of her essence which is dispensed by the game.  A Raspberry Pi runs a sketch written in Python to control audio playback, game state changes, and serial communication with an Arduino Nano connected via USB.  The Nano runs a script written to receive and send data to the Pi as well as control the motors, sensor input and various lighting elements.  CAD models of the dispenser and parts were designed using Fusion 360 which allowed for parts to be imported directly from McMaster-Carr.  When designs were finalized, parts were 3D printed, ordered from McMaster- Carr or built at my workshop.  Once assembled, testing took place over the course of many days to ensure all mechanism were flawless before both dispensers were shipped to a fabrication shop who would incorporate my design into the final build.",
            "tech": [
                [
                    "Arduino",
                    "https://www.arduino.cc/"
                ],
                [
                    "Raspberry Pi",
                    "https://www.raspberrypi.org/"
                ],
                [
                    "Python",
                    "https://www.python.org/"
                ]
            ],
            "photos": [
                "vial-dispenser/vial-dispenser-01.jpg",
                "vial-dispenser/vial-dispenser-02.jpg",
                "vial-dispenser/vial-dispenser-03.jpg",
                "vial-dispenser/vial-dispenser-04.jpg",
                "vial-dispenser/vial-dispenser-05.jpg",
                "vial-dispenser/vial-dispenser-06.jpg",
                "vial-dispenser/vial-dispenser-07.jpg",
                "vial-dispenser/vial-dispenser-08.jpg",
                "vial-dispenser/vial-dispenser-09.jpg",
                "vial-dispenser/vial-dispenser-10.jpg",
                "vial-dispenser/vial-dispenser-11.jpg",
                "vial-dispenser/vial-dispenser-12.jpg",
                "vial-dispenser/vial-dispenser-13.jpg",
                "vial-dispenser/vial-dispenser-14.jpg",
                "vial-dispenser/vial-dispenser-15.jpg",
                "vial-dispenser/vial-dispenser-16.jpg",
                "vial-dispenser/vial-dispenser-17.jpg",
                "vial-dispenser/vial-dispenser-18.jpg",
                "vial-dispenser/vial-dispenser-19.jpg",
                "vial-dispenser/vial-dispenser-20.jpg",
                "vial-dispenser/vial-dispenser-21.jpg",
                "vial-dispenser/vial-dispenser-22.jpg",
                "vial-dispenser/vial-dispenser-23.jpg"
            ]
        },
        {
            "name": "CC Robot",
            "group": "Lane",
            "grouplinks": "#",
            "link": "cc-robot",
            "date": "Jun 2018-2020",
            "short": "A midi controlled automaton",
            "info": "The talented Lane Shi Otayonii created CC Robot for her Automation Alive piece.  CC Robot uses a Teensy 4.0 to receive MIDI input from a score created in Ableton Live to control the various motors, sensors and LEDs mounted in CC.  Each arm uses a DC motor and a two servo motors to make gestures such as hugging, embracing the crowd and touching its head.  A servo motor is used to move the mouth to allow CC to lip sync with the audio track during part of the performance.  A WS2812 LED ring is mounted inside the head illuminates the silicon mold mounted on top.  Brackets for mounting the plastic shells, silicon molds, LEDs, motors and other various components were modeled using Fusion 360 and 3D printed on a Flashforge Creator Pro.",
            "tech": [
                [
                    "Arduino",
                    "https://www.arduino.cc/"
                ],
                [
                    "Teensy",
                    "https://www.pjrc.com/teensy/"
                ],
                [
                    "WS2812b",
                    "https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf"
                ],
                [
                    "MIDI",
                    "https://en.wikipedia.org/wiki/MIDI"
                ]
            ],
            "photos": [
                "cc-robot/cc-robot-01.jpg",
                "cc-robot/cc-robot-02.jpg",
                "cc-robot/cc-robot-03.jpg",
                "cc-robot/cc-robot-04.jpg",
                "cc-robot/cc-robot-05.jpg",
                "cc-robot/cc-robot-06.jpg",
                "cc-robot/cc-robot-07.jpg",
                "cc-robot/cc-robot-08.jpg",
                "cc-robot/cc-robot-09.jpg",
                "cc-robot/cc-robot-10.jpg",
                "cc-robot/cc-robot-11.jpg",
                "cc-robot/cc-robot-12.jpg",
                "cc-robot/cc-robot-13.jpg",
                "cc-robot/cc-robot-14.jpg",
                "cc-robot/cc-robot-15.jpg",
                "cc-robot/cc-robot-16.jpg",
                "cc-robot/cc-robot-17.jpg"
            ]
        },
        {
            "name": "Open The Wound",
            "group": "Lane",
            "grouplinks": "#",
            "link": "open-the-wound",
            "date": "Jun 2018-2020",
            "short": "A prototype for an art project",
            "info": "Working with Lane Shi Otayonii, I designed and built a prototype to work out the details of a new piece.  The wood frame would be mounted on the ceiling and open up to reveal a mounted TV playing video clips.  A Raspberry Pi was used to run a Python script to play the videos used in the piece.  An Arduino Nano was used to monitor the start/stop button and control the DC motors to open/close the frame.  Hall effect sensors were used for home and end-stop positions.  Custom gears, motor and sensor mounts were 3D printed and designed in Fusion 360 along with the CAD for the frame.",
            "tech": [
                [
                    "Arduino",
                    "https://www.arduino.cc/"
                ],
                [
                    "Raspberry Pi",
                    "https://www.raspberrypi.org/"
                ],
                [
                    "Python",
                    "https://www.python.org/"
                ],
                [
                    "Fusion 360",
                    "https://www.autodesk.com/products/fusion-360/overview"
                ]
            ],
            "photos": [
                "open-the-wound/open-the-wound-1.jpg",
                "open-the-wound/open-the-wound-2.jpg",
                "open-the-wound/open-the-wound-3.jpg",
                "open-the-wound/open-the-wound-4.jpg",
                "open-the-wound/open-the-wound-5.jpg",
                "open-the-wound/open-the-wound-6.jpg",
                "open-the-wound/open-the-wound-7.jpg",
                "open-the-wound/open-the-wound-8.jpg"
            ]
        },
        {
            "name": "Moose Goldberg",
            "group": "ARCH NYC",
            "grouplinks": "#",
            "link": "moose-goldberg",
            "date": "Jun 2018-2020",
            "short": "A two story Rube Goldberg inspired dumb waiter",
            "info": "Moose Goldberg was a Rube Goldberg inspired two story dumb waiter designed and fabricated by ARCH Productions for the launch of Moose Knuckle's new store located in New York City, NY.  The machine included a functional dumb waiter to move coats between floors as well as numerous mechanical elements such as a sequence of automated bobble heads, Newton's Cradle and a coat hanger which moved a coat around the structure on a custom designed track.  An Arduino Mega was used to control the many motors and sensors throughout the structure.  A script written in the Arduino IDE controlled each of the elements through a timed sequence of events.  Each of the elements movements were written in a non-blocking fashion to allow for multiple actions to take place at the same time such as sensor readings and motor position changes.  A large red button was used as the start button for the events.  Certain elements required parts which could not be bought.  These were modeled in Fusion 360 and 3D printed using a Flashforge Creator Pro.  The dumb waiter acted independently from the ascetic elements which were triggered when a large red button at the base of the structure was pressed.",
            "tech": [
                [
                    "Arduino",
                    "https://www.arduino.cc/"
                ],
                [
                    "Raspberry Pi",
                    "https://www.raspberrypi.org/"
                ],
                [
                    "Fusion 360",
                    "https://www.autodesk.com/products/fusion-360/overview"
                ]
            ],
            "photos": [
                "moose-goldberg/moose-goldberg-01.jpg",
                "moose-goldberg/moose-goldberg-02.jpg",
                "moose-goldberg/moose-goldberg-03.jpg",
                "moose-goldberg/moose-goldberg-04.jpg",
                "moose-goldberg/moose-goldberg-05.jpg",
                "moose-goldberg/moose-goldberg-06.jpg",
                "moose-goldberg/moose-goldberg-07.jpg",
                "moose-goldberg/moose-goldberg-08.jpg",
                "moose-goldberg/moose-goldberg-09.jpg",
                "moose-goldberg/moose-goldberg-10.jpg",
                "moose-goldberg/moose-goldberg-11.jpg",
                "moose-goldberg/moose-goldberg-12.jpg",
                "moose-goldberg/moose-goldberg-13.jpg",
                "moose-goldberg/moose-goldberg-14.jpg",
                "moose-goldberg/moose-goldberg-15.jpg",
                "moose-goldberg/moose-goldberg-16.jpg",
                "moose-goldberg/moose-goldberg-17.jpg",
                "moose-goldberg/moose-goldberg-18.jpg",
                "moose-goldberg/moose-goldberg-19.jpg",
                "moose-goldberg/moose-goldberg-20.jpg",
                "moose-goldberg/moose-goldberg-21.jpg"
            ]
        },
        {
            "name": "Moncler Genius Tunnel",
            "group": "ARCH NYC",
            "grouplinks": "#",
            "link": "moncler-genius-tunnel",
            "date": "Jun 2018-2020",
            "short": "A massive LED infinite tunnel",
            "info": "The Genius Tunnel was a massive storefront display built for Moncler's two Hawaii locations.  The each of the series of tunnels were controlled using a Raspberry Pi to control the hundreds of feet of RGB LEDs wired through each structure.  The LEDs were controlled using a daisy chain of LED DMX decoders connected to an eDMX Pro interface, which was then plugged into the Raspberry Pi's USB port.  A script written in the Processing IDE controlled the LED lighting sequences.",
            "tech": [
                [
                    "Raspberry Pi",
                    "https://www.raspberrypi.org/"
                ],
                [
                    "Processing IDE",
                    "https://processing.org/"
                ],
                [
                    "DMX",
                    "https://en.wikipedia.org/wiki/DMX512"
                ]
            ],
            "photos": [
                "moncler-genius-tunnel/moncler-01.jpg",
                "moncler-genius-tunnel/moncler-02.jpg",
                "moncler-genius-tunnel/moncler-03.jpg",
                "moncler-genius-tunnel/moncler-04.jpg",
                "moncler-genius-tunnel/moncler-05.jpg",
                "moncler-genius-tunnel/moncler-06.jpg",
                "moncler-genius-tunnel/moncler-07.jpg",
                "moncler-genius-tunnel/moncler-08.jpg",
                "moncler-genius-tunnel/moncler-09.jpg",
                "moncler-genius-tunnel/moncler-10.jpg"
            ]
        }
    ]
}